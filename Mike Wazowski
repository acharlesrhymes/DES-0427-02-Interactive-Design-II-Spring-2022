//let intCurrentRadius= 0;
//let intCalculationX =0;
//let intCalculationY = 0;
//let intCurrentX = 400;
//let intCurrentY = 400;


function setup() {
  createCanvas(800, 800);
  noStroke();
  fill(255);
  
}

function drawMyBackground() {
  background('rgba(11,217,200,0.08)');
  //background('#0BD9C8');
}

// snowflake class
function snowflake() {
  // initialize coordinates
  this.posX = 0;
  this.posY = random(-50, 0);
  this.initialangle = random(0, 2 * PI);
  this.size = random(2, 5);

  // radius of snowflake spiral
  // chosen so the snowflakes are uniformly spread out in area
  this.radius = sqrt(random(pow(width / 2, 2)));

  this.update = function(time) {
    // x position follows a circle
    let w = 0.6; // angular speed
    let angle = w * time + this.initialangle;
    this.posX = width / 2 + this.radius * sin(angle);

    // different size snowflakes fall at slightly different y speeds
    this.posY += pow(this.size, 0.5);

    // delete snowflake if past end of screen
    if (this.posY > height) {
      let index = snowflakes.indexOf(this);
      snowflakes.splice(index, 1);
    }
  };

  this.display = function() {
    ellipse(this.posX, this.posY, this.size);
  };
}



function drawEars() {
  
stroke('#11ee55');
  fill('#11ee55');  
 triangle(255, 370, 240, 220, 370, 260);
  stroke('#11ee55');
  fill('#11ee55');
  triangle(430, 260, 560, 220, 545, 370); 
  
}



function drawBody() {
  fill('#11ee55');
 ellipse(400,400,400,400);  
 
}


function drawEyeBase() {
  fill(255);
  ellipse(400,400,200,200);
}

function drawIris() {
   let x = map(mouseX,0,800,-400,400);
   let y = map(mouseY,0,800,-400,400); 
   let r = sqrt(pow(x,2)+pow(y,2)); 
   let m = y/x;
   
  
  let maxRadius = 51;
  
   fill(20);
    
   if(r<maxRadius) {
      ellipse(x+400,y+400,100,100);
   }
   else {
     let xPos = sqrt( (pow(maxRadius,2)) / (1 + pow(m,2)) );
     
     if(x<0) {
       xPos *= -1;
     }
     
     let yPos = m*xPos;
      
     ellipse(xPos+400,yPos+400,100,100);
   }
}

function drawEyeBase() {
  fill(255);
  ellipse(400,400,200,200);
}

function drawIris() {
   noStroke();
   let x = map(mouseX,0,800,-400,400); //as if the center is in (0,0)
   let y = map(mouseY,0,800,-400,400); //as if the center is in (0,0)
   let r = sqrt(pow(x,2)+pow(y,2)); //calculates radius from (0,0) to (x,y)
   let m = y/x;
   
  let maxRadius = 51; //the radius defines an invisible boundary (circle)
  
    
   if(r<maxRadius) { //if it falls inside the white circle
     fill(30);
     ellipse(x+400,y+400,100,100);
     //(x,y) consider (0,0) as the origin. To take (x,y) back inside the canvas, you need to shift (x,y) to recenter the center of the ellipses 

     fill('#0984e3');
     ellipse(x+400,y+400,80,80);

     fill(30);
     ellipse(x+400,y+400,50,53);

     fill(250);
     ellipse(x+415,y+385,40,40);
   }
   else { //if it falls outside the white circle
     let xPos = sqrt( (pow(maxRadius,2)) / (1 + pow(m,2)) ); //after solving for x, using the line equation and circle equation
     
     if(x<0) { //is the translated x on the right or left of origin?
       xPos *= -1; //if it is: flip its sign to indicate the left side of origin
     }
     
     let yPos = m*xPos; //after solving for y, using the line equation and circle equation
    
     //drawing the eye base
     fill(30);
     ellipse(xPos+400,yPos+400,100,100);

     //drawing the iris
     fill('#0984e3');
     
     ellipse(xPos+400,yPos+400,80,80);

     //drawign the pupil
     fill(30);
     
     ellipse(xPos+400,yPos+400,50,53);

     //drawing the light spot
     fill(250);
     ellipse(xPos+415,yPos+385,40,40);
     
      if(mouseIsPressed) {
       //ellipse(mouseX,mouseY,30,30);
      translate(mouseX, mouseY);//you need to do the rotation regarding a center: this will tell the lines below to consider (mouseX,mouseY) to be the center when rotate is called
      noStroke();
      for (let i = 0; i < 10; i ++) {
         fill('#3498db');
         ellipse(0, 10, 12, 36);
         rotate(PI/5);

         fill('#f1c40f');
         ellipse(0, 5, 12, 36);
         rotate(PI/5);
        
      } //end of cycle that draws star
       
      resetMatrix(); //the translate above messes up with the pivot (point from which everything draws). You need to bring this pivot to to the origin (0,0) with this function so that the mouseX and mouseY is calculated regarding (0,0)

       fill('#ecf0f1');
       ellipse(mouseX,mouseY,18,18);

       fill('#e74c3c');
       ellipse(mouseX,mouseY,10,10);
       
     } //end of mouseIsPressed
    
   } //end of if it falls outside the circle
    
   }





function drawSmile() {
  fill(0);
  arc(400, 507, 240, 150, 0, PI, OPEN,);
}



function drawTeeth() {
  fill(255);
  rect(310, 507, 55, 25);
  rect(440, 507, 55, 25);
}


function drawTongue() {
  fill('#d1908e');
  let m = map(mouseY,0,height,5,235)
  
  arc(400, 568, 140, m, 0, PI, OPEN);
}

function draw() {
  drawMyBackground();
  drawEars();
  drawBody();
  drawEyeBase();
  drawIris();
  drawSmile();
  drawTeeth();
  drawTongue();
}
